# 继承
# 原型链

基本思想：利用原型链让一个引用类型继承另一个引用类型的属性和方法。  

构造函数、原型和实例的关系：  
构造函数都有原型对象，  
原型对象都有一个指向构造函数的指针，  
实例都包含一个指向原型对象的内部指针（振戈内部指针大多数时候是不可直接访问的）  

如果把一个构造函数的实例赋给另一个构造函数的原型对象，那么此时的原型对象将包含另一个  
原型的指针，相应的，另一个原型中也包含着另一个构造函数的指针，这样层叠即可形成原型链。  

# 默认的原型  

所有引用类型默认都继承了Object，而这个继承也都是通过原型链来实现的。所有函数的默认原型都是  
Object的实例，因此默认原型都会包含一个内部指针，指向Object.prototype,这也就是所有自定义类型  
都会继承toString(),valueOf()等方法的原因。  

# 确定原型和实例的关系

instanceof/isPrototypeOf 测试实例与原型链中出现过的构造函数，就会返回true

# 定义方法

若在子类的prototype上定义一个原型链已经存在的方法，则这个方法只会影响赋给子类原型对象的那个父类对象  
而不会影响父类的原型，父类继续new新对象则调的是父类原型对象的方法。  

# 原型链的缺点

1.若父类有一个属性，虽然每创建一个父类实例都有自己的属性，但当把一个父类对象赋给子类的prototype时，  
相当于设置了child.prototype.field = xxx，所有子类对象共享了一个属性，尤其是当此属性为引用类型时会出现问题。  
2.在创建子类型的实例时，不能像超类型的构造函数中传递参数  

# 借用构造函数-伪造对象-经典继承-这帮人真xxx聪明

为了解决原型链继承中的包含引用类型值所带来的问题相处的点子：  

function supType(){  
this.colors = ['red','blue'];  
}  
function subType(){  
    supType.call/apply(this);//而且这么做貌似能解决原型链中父类不能传入构造参数的问题？？  
}  
果然是有可传参这个好处的，咩哈哈  

# 借用构造函数的问题

1.单独使用借用构造函数模式，方法都在构造函数中定义，造成重复  
2.在超类原型中定义的方法，在子类中是不可见的  
1,2两点是一个解决另一个必然出现  

# NB的组合继承  

指将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的继承模式。其背后的思路是：  
使用原型链实现对原型属性和方法的继承，通过借用构造函数实现对实例属性的继承。  


175





























































